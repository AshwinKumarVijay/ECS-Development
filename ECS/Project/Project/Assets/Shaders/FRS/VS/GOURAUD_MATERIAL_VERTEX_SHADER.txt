#version 430 core


uniform vec3 ambientLight;

#define MAX_LIGHTS 3
struct Light
{
	vec3 enabledLocalLightType;
	vec4 colorAndLightIntensity;
	vec4 position;
	vec3 coneDirection;
	vec3 attenuation;
	vec3 spotCosCutOffAndExponent;
};
uniform Light Lights[MAX_LIGHTS];


struct Material
{
	vec3 diffuseAlbedo;
	vec3 specularAlbedo;
	vec3 emissiveColor;
	vec3 metallicnessRoughnessOpacity;
};
uniform Material CurrentMaterial;


struct Camera
{
	vec3 worldCameraPosition;
	mat4 perspectiveMatrix;
	mat4 viewMatrix;
};
uniform Camera CurrentCamera;

struct Model
{
	mat4 modelMatrix;
	mat3 inverseModelMatrix;
	mat3 normalMatrix;
};
uniform Model CurrentModel;


layout (location = 0) in vec3 vertex_position;
layout (location = 1) in vec3 vertex_normal;
layout (location = 2) in vec4 vertex_color;


layout (location = 0) out vec4 vertex_color_out;


void computeDiffuseSpecularLightingColor(in int lightNumber, in vec4 currentVertexPosition, in vec3 currentNormal, in vec3 currentMaterialDiffuseAlbedo, in vec3 currentMaterialSpecularAlbedo, in float currentMaterialMetallicness, in float currentMaterialRoughness, out vec3 computedDiffuseColor, out vec3 computedSpecularColor)
{
	vec3 transformed_normal = normalize(CurrentModel.normalMatrix * currentNormal);
	vec4 transformed_vertex_position = CurrentCamera.viewMatrix * CurrentModel.modelMatrix * currentVertexPosition;
	vec3 view_vector = normalize(-transformed_vertex_position.xyz);
	vec4 light_position = CurrentCamera.viewMatrix * Lights[lightNumber].position;

	vec3 vertex_to_light = normalize(vec3(light_position - transformed_vertex_position));
	vec3 reflected_light = reflect(-vertex_to_light, transformed_normal);


	float diffuse_intensity = max(dot(vertex_to_light, transformed_normal), 0.0);
	computedDiffuseColor = currentMaterialDiffuseAlbedo * Lights[lightNumber].colorAndLightIntensity.xyz * diffuse_intensity * (1.0/3.14) * Lights[lightNumber].colorAndLightIntensity.w * (1.0 - currentMaterialMetallicness);

	float specularIntensity = max(dot(reflected_light, view_vector), 0.0);
	computedSpecularColor = pow(specularIntensity, currentMaterialRoughness + 1.0) * currentMaterialSpecularAlbedo * ((currentMaterialRoughness + 2.0) / (2 * 3.14)) * Lights[lightNumber].colorAndLightIntensity.w * currentMaterialMetallicness;
}


void applyMaterialEffects(out vec3 currentMaterialDiffuseAlbedo, out vec3 currentMaterialSpecularAlbedo, out vec3 currentMaterialEmissiveColor, out float currentMaterialMetallicness, out float currentMaterialRoughness, out float currentMaterialOpacity)
{
	currentMaterialDiffuseAlbedo = CurrentMaterial.diffuseAlbedo;
	currentMaterialSpecularAlbedo = CurrentMaterial.specularAlbedo;
	currentMaterialEmissiveColor = CurrentMaterial.emissiveColor;
	currentMaterialMetallicness = CurrentMaterial.metallicnessRoughnessOpacity[0];
	currentMaterialRoughness = CurrentMaterial.metallicnessRoughnessOpacity[1];
	currentMaterialOpacity = CurrentMaterial.metallicnessRoughnessOpacity[2];
}



void main()
{	

	
	vec3 materialDiffuseAlbedo;
	vec3 materialSpecularAlbedo;
	vec3 materialEmissive;
	float materialMetallicness;
	float materialRoughness;
	float materialOpacity;

	applyMaterialEffects(materialDiffuseAlbedo, materialSpecularAlbedo, materialEmissive, materialMetallicness, materialRoughness, materialOpacity);

	vec3 diffuseLightingColor = vec3(0.0, 0.0, 0.0);
	vec3 specularLightingColor = vec3(0.0, 0.0, 0.0);

	vec3 allDiffuseLightingColor = vec3(0.0, 0.0, 0.0);
	vec3 allSpecularLightingColor = vec3(0.0, 0.0, 0.0);


	for(int i = 0; i < MAX_LIGHTS; i++)
	{
		if(Lights[i].enabledLocalLightType[0] == 1.0)
		{
			computeDiffuseSpecularLightingColor(i, vec4(vertex_position, 1.0), vertex_normal, materialDiffuseAlbedo.xyz, materialSpecularAlbedo, materialMetallicness, materialRoughness, diffuseLightingColor, specularLightingColor);
			allDiffuseLightingColor += diffuseLightingColor;
			allSpecularLightingColor += specularLightingColor;
		}
	}

	vertex_color_out = vec4(ambientLight * materialMetallicness + allSpecularLightingColor + materialEmissive + allDiffuseLightingColor * materialDiffuseAlbedo.xyz, materialOpacity);
	gl_Position = CurrentCamera.perspectiveMatrix * CurrentCamera.viewMatrix * CurrentModel.modelMatrix * vec4(vertex_position, 1.0);
}



