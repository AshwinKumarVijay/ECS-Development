#version 430 core

// CONSTANTS - PI
const float PI = 3.1415926535897932384626433832795;
const float PI_2 = 1.57079632679489661923;
const float PI_4 = 0.785398163397448309616;

//	MAX LIGHTS
#define MAX_LIGHTS 16

//	MAX SAMPLES
#define BITS_USED 7
#define SAMPLES_NUMBER pow(2, BITS_USED)
#define BINARY_FRACTION (1.0f / ((pow(2.0, float(BITS_USED))) - 1.0f))

//	ENVIRONMENT MAP SAMPLER CUBE.
layout (binding = 0) uniform samplerCube u_EnvironmentMap;


//	CAMERA DATA. UNIFORM CAMERA POSITION, CAMERA PERSPECTIVE MATRIX, CAMERA VIEW MATRIX.
layout (location = 10) uniform vec4 u_WorldCameraPosition;
layout (location = 11) uniform mat4 u_CameraPerspectiveMatrix;
layout (location = 12) uniform mat4 u_CameraViewMatrix;

//	MODEL DATA. UNIFORM MODEL, INVERSE MODEL, NORMAL MATRIX.
layout (location = 20) uniform mat4 u_ModelMatrix;
layout (location = 21) uniform mat3 u_InverseTransposeModelMatrix;
layout (location = 22) uniform mat4 u_ModelViewMatrix;
layout (location = 23) uniform mat3 u_InverseTransposeModelViewMatrix;

//	MATERIAL DATA. DIFFUSE ALBEDO, METALLICNESS, ROUGHNESS, FRESNEL, OPACITY.
layout (location = 25) uniform vec4 u_diffuseAlbedo;
layout (location = 26) uniform vec4 u_materialMetallicnessRoughnessFresnelOpacity;


//	SAMPLING CONSTANTS FOR HAMMERSLY SAMPLING.
layout (location = 40) uniform uint u_samplesNumber;
layout (location = 41) uniform uint u_bitsUsed;
layout (location = 42) uniform float u_binaryFractionFactor;

//	
uniform vec3 u_AmbientLight;

struct Light
{
	//	
	vec4 lightEnabledLocalLightType;

	//	
	vec4 lightColorAndLightIntensity;

	//	
	vec4 lightPosition;

	//	
	vec4 lightConeDirection;

	//	
	vec4 lightAttenuation;

	//	
	vec4 lightSpotCosCutOffAndExponent;
};

//	The Array of Lights.
uniform Light u_Lights[MAX_LIGHTS];


//	VERTEX ATTRIBUTES
//	VERTEX POSITION, VERTEX NORMAL, VERTEX TANGENT, VERTEX BITANGENT.
layout (location = 0) in vec4 v_vertexposition;
layout (location = 1) in vec3 v_normal;
layout (location = 2) in vec4 v_vertexcolor;
layout (location = 3) in vec3 v_tangent;
layout (location = 4) in vec3 v_bitangent;

//	FRAGMENT COLOR.
layout (location = 0) out vec4 o_fragColor;

//	Compute the Hammersley Sample from the Original Sample
//	@in uint originalSample		:	The i to use in the Hammersly Sample.
//	@out vec2 hammersleySample	:	The resultant Hammersly Sample.
void computeHammerslySample(in uint originalSample, out vec2 hammersleySample)
{
	uint revertSample;

	// Revert bits by swapping blockwise. Lower bits are moved up and higher bits down.
	revertSample = (originalSample << 16u) | (originalSample >> 16u);
	revertSample = ((revertSample & 0x00ff00ffu) << 8u) | ((revertSample & 0xff00ff00u) >> 8u);
	revertSample = ((revertSample & 0x0f0f0f0fu) << 4u) | ((revertSample & 0xf0f0f0f0u) >> 4u);
	revertSample = ((revertSample & 0x33333333u) << 2u) | ((revertSample & 0xccccccccu) >> 2u);
	revertSample = ((revertSample & 0x55555555u) << 1u) | ((revertSample & 0xaaaaaaaau) >> 1u);

	// Shift back, as only m bits are used.
	revertSample = revertSample >> (32 - BITS_USED);

	hammersleySample = vec2(float(revertSample) * BINARY_FRACTION, float(originalSample) * BINARY_FRACTION);
}


//	Compute the Microfacet Weighted Sample
//	@in float roughness		:	The Material Roughness.
//	@in vec2 randomPoint	:	The Random Point.
//	@out vec3 randomSample	:	The Random Sample.
void microfacetWeightedSampling(in float roughness, in vec2 randomPoint, out vec3 randomSample)
{
	float alpha = roughness * roughness;
	
	// Note: Polar Coordinates
	// x = sin(theta)*cos(phi)
	// y = sin(theta)*sin(phi)
	// z = cos(theta)
	
	float phi = 2.0 * PI * randomPoint.y; 	
	float cosTheta = sqrt((1.0 - randomPoint.x) / (1.0 + (alpha*alpha - 1.0) * randomPoint.x));
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta); 

	float x = sinTheta * cos(phi);
	float y = sinTheta * sin(phi);
	float z = cosTheta;

	randomSample = vec3(x, y, z);
}



//	Compute the Cosine Weighted Sample
//	@in vec2 randomPoint	:	The Random Point.
//	@out vec3 randomSample	:	The Resultant Random Sample.
void cosineWeightedSampling(in vec2 randomPoint, out vec3 randomSample)
{
	float x = sqrt(1.0 - randomPoint.x) * cos(2.0 * PI * randomPoint.y);
	float y = sqrt(1.0 - randomPoint.x) * sin(2.0 * PI * randomPoint.y);
	float z = sqrt(randomPoint.x);
	
	randomSample = vec3(x, y, z);
}


//	Compute the Fresnel Schlick Approximation.
//	@in float materialR0		:	The Material R0
//	@in float viewDotHalf		:	The View Vector Dot Half Vector.
//	@out float fresnelFactor	:	The Fresnel Factor.
void computeFresnelSchlickApproximation(in float materialR0, in float VdotH, out float fresnelFactor)
{
	fresnelFactor = materialR0 + ((1.0 - materialR0) * pow(1.0 - VdotH, 5.0));
}


//	Compute Tangent and Bitangent Basis, in world space.
//	@in vec2 randomPoint	: The Random Point to use for Sampling.
//	@in mat3 basis			: The Basis for Coverting to World Space.
//	@out vec3 lambertColor	: The Lambertian Color.
void computeBRDFLambert(in vec2 randomPoint, in mat3 basis, out vec3 lambertColor)
{
	//	The Incoming Light In Tangent Space.
	vec3 LightTangentSpace = vec3(0.0, 0.0, 0.0);

	//	The Cosine Weighted Sampling.
	cosineWeightedSampling(randomPoint, LightTangentSpace);

	//	Convert from Light Tangent Space to Light World Space.
	vec3 L = basis * LightTangentSpace;

	//	The Lambert Color.
	lambertColor = u_diffuseAlbedo.xyz * (normalize(L)).xyz;
}


//	Compute Geometric Shadowing, according to the Schlick-Beckmann Distribution.
//	@in float NdotV		: 
//	@in float k			: 
//	@out float gSB		: 
void geometricShadowingSchlickBeckmann(in float NdotV, in float k, out float gSB)
{
	gSB = NdotV / (NdotV * (1.0 - k) + k);
}

//	Compute the Geometric Shadowing, accoring to Smith.
//	@in float NdotL		:
//	@in float NdotV		:
//	@in float k			:
//	@out float gSF		: 
void geometricShadowingSmith(in float NdotL, in float NdotV, in float k, out float gSF)
{
	float gSSB1 = 0.0;
	float gSSB2 = 0.0;
	
    geometricShadowingSchlickBeckmann(NdotL, k, gSSB1);
    geometricShadowingSchlickBeckmann(NdotV, k, gSSB2);

	gSF = gSSB1 * gSSB2;
}


//	Compute Specular Highlight, according to the Cook Torrance BRDF.
//	@in vec2 randomPoint	: The Random Point to use for Sampling.
//	@in mat3 basis			: The Basis for Coverting to World Space.
//	@in vec3 normal			: The Surface Normal.
//	@in vec3 viewVector		: The View Vector.
//  @in float roughness     : The Roughness of the Material.
//  @in float materialR0    : The Fresnel Factor of the Material.
//	@out vec3 specularColor : The Specular Color.
void computeBRDFSpecularCookTorrance(in vec2 randomPoint, in mat3 basis, in vec3 N, in vec3 V, in float roughness, in float materialR0, out vec3 specularColor)
{

	//	Initialize the Color.
	specularColor = vec3(0.0, 0.0, 0.0);

	//	
	vec3 HtangentSpace = vec3(0.0, 0.0, 0.0);
    microfacetWeightedSampling(roughness, randomPoint, HtangentSpace);

	//
	vec3 H = normalize(basis * HtangentSpace);

	// Note: reflect takes incident vector.
	vec3 L = reflect(-V, H);
	
	//	
	float NdotL = clamp(dot(N, L), 0, 1);
	float NdotV = clamp(dot(N, V), 0, 1);
	float NdotH = clamp(dot(N, H), 0, 1);

	// Lighted and visible
	if (NdotL > 0.0 && NdotV > 0.0)
	{
		//	
		float VdotH = clamp(dot(V, H), 0, 1);

		//	Compute the Half Vector.
		float F = 0.0;
		computeFresnelSchlickApproximation(materialR0, VdotH, F);

		float G = 0.0;
		geometricShadowingSmith(NdotL, NdotV, roughness, G); 

		float colorFactor = F * G * VdotH / (NdotV * NdotH);

		if (isnan(colorFactor))
		{
			specularColor = vec3(0.0, 0.0, 0.0);
		}

		specularColor = (normalize(L)).xyz * colorFactor;
	}

}


//	THE FRAGMENT SHADER MAIN.
void main(void)
{
	//	Initialize the Color.
	vec3 color = vec3(0.0, 0.0, 0.0);

	//	Compute the Normalized Normal, Tangent and Bitangent.
	vec3 normal = normalize(v_normal);
	vec3 tangent = normalize(v_tangent);
	vec3 bitangent = normalize(v_bitangent);

	//	Tangent, Bitangent and Normal.
	mat3 basis = mat3(tangent, bitangent, normal);

    //  
    float materialMetallicness = u_materialMetallicnessRoughnessFresnelOpacity[0];
    float materialRoughness = u_materialMetallicnessRoughnessFresnelOpacity[1];
    float materialFresnelFactor = u_materialMetallicnessRoughnessFresnelOpacity[2];
    float materialOpacity = u_materialMetallicnessRoughnessFresnelOpacity[3];

	//	Disney style Remapped Roughness.
	float remappedRoughness = ((materialRoughness + 1.0) * (materialRoughness + 1.0)) / 8.0;
    
    //  
    vec3 viewVector = normalize((u_WorldCameraPosition.xyz - v_vertexposition.xyz));

	//	Compute color per sample.
	for(uint sampleIndex = 0; sampleIndex < SAMPLES_NUMBER; sampleIndex++)
	{	

		//	Hammersly Sample Point.
		vec2 hammerslySamplePoint = vec2(0.0, 0.0);
		computeHammerslySample(sampleIndex, hammerslySamplePoint);

		//	
		vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
		computeBRDFLambert(hammerslySamplePoint, basis, diffuseColor);
	
		//	
		vec3 specularColor = vec3(0.0, 0.0, 0.0);
		computeBRDFSpecularCookTorrance(hammerslySamplePoint, basis, normal, viewVector, materialRoughness, materialFresnelFactor, specularColor);

		//	
		color += (1 - materialMetallicness) * diffuseColor + materialMetallicness * specularColor;
	}


	//	Frag Color.
	o_fragColor = vec4(color, 1.0);
}