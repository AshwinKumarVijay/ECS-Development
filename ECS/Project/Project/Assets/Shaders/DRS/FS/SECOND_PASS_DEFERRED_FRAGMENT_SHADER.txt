#version 430 core

uniform vec3 ambient_light;

uniform struct Light
{
	vec3 enabledLocalLightType;
	vec4 colorAndLightIntensity;
	vec4 position;
	vec3 coneDirection;
	vec3 attenuation;
	vec3 spotCosCutOffAndExponent;
};

#define MAX_LIGHTS 16
uniform Light Lights[MAX_LIGHTS];

uniform struct Camera
{
	vec3 worldCameraPosition;
	mat4 perspectiveMatrix;
	mat4 viewMatrix;
};

uniform Camera CurrentCamera;


in vec4 texture_coordinates;

layout (location = 0) uniform sampler2D vertex_position_sampler;
layout (location = 1) uniform sampler2D vertex_normal_and_materialID_sampler;
layout (location = 2) uniform sampler2D vertex_texture_coordinates_sampler;
layout (location = 3) uniform sampler2D diffuse_albedo_sampler;
layout (location = 4) uniform sampler2D specular_albedo_and_roughness_sampler;
layout (location = 5) uniform sampler2D emission_and_metallicness_sampler;



out vec4 color;


void computeMaterialAmbientLighting(in vec3 ambientLight, in float currentMaterialMetallicness, out vec3 computedAmbientColor)
{
    computedAmbientColor = ambientLight * currentMaterialMetallicness;
}

void computeMaterialDiffuseLighting(in vec3 currentNormal, in vec3 viewVector, in vec3 vertexToLightDirection, in vec3 lightColor, in float lightIntensity, in vec3 currentMaterialDiffuseAlbedo, in float currentMaterialMetallicness, 
                                    out vec3 computedDiffuseColor)
{

    float diffuseIntensity = max(dot(vertexToLightDirection, currentNormal), 0.0);
    computedDiffuseColor = currentMaterialDiffuseAlbedo * lightColor * diffuseIntensity * (1.0/3.14) * lightIntensity * (1.0 - currentMaterialMetallicness);
}


void computeMaterialSpecularLighting(in vec3 currentNormal, in vec3 viewVector, in vec3 reflectedLightDirection, in vec3 lightColor, in float lightIntensity, in vec3 currentMaterialSpecularAlbedo, in float currentMaterialMetallicness, in float currentMaterialRoughness, out vec3 computedSpecularColor)
{

	float specularIntensity = max(dot(reflectedLightDirection, viewVector), 0.0);
	computedSpecularColor = pow(specularIntensity, currentMaterialRoughness + 1.0) * currentMaterialSpecularAlbedo * ((currentMaterialRoughness) / (2 * 3.14)) * lightIntensity * currentMaterialMetallicness;    
}

void computeMaterialLighting(in vec4 currentVertexPosition, in vec3 currentNormal, in vec3 viewVector, in vec3 vertexToLightDirection, in vec3 reflectedLightDirection, in vec3 lightColor, in float lightIntensity, in vec3 currentMaterialDiffuseAlbedo, in vec3 currentMaterialSpecularAlbedo, in float currentMaterialMetallicness, in float currentMaterialRoughness, out vec3 computedLightingColor)
{
    vec3 computedAmbientColor;
    computeMaterialAmbientLighting(ambient_light, currentMaterialMetallicness, computedAmbientColor);

    vec3 computedDiffuseColor;
    computeMaterialDiffuseLighting(currentNormal, viewVector, vertexToLightDirection, lightColor, lightIntensity, currentMaterialDiffuseAlbedo, currentMaterialMetallicness, computedDiffuseColor); 
    
    vec3 computedSpecularColor;
    computeMaterialSpecularLighting(currentNormal, viewVector, reflectedLightDirection, lightColor, lightIntensity, currentMaterialSpecularAlbedo, currentMaterialMetallicness, currentMaterialRoughness, computedSpecularColor);
    
    computedLightingColor = computedAmbientColor + computedDiffuseColor + computedSpecularColor;
}

void computeRequiredPointLightProperties(in vec4 currentVertexPosition, in vec3 currentNormal, in vec3 viewVector, in int lightNumber, out vec3 vertexToLightDirection, out vec3 reflectedLightDirection, out vec3 lightColor, out float lightIntensity)
{
	vec4 current_light_position = CurrentCamera.viewMatrix * Lights[lightNumber].position;
    vertexToLightDirection = normalize((current_light_position - currentVertexPosition).xyz);
    reflectedLightDirection = reflect(-vertexToLightDirection, currentNormal);
    lightIntensity = Lights[lightNumber].colorAndLightIntensity.w;
	lightColor = Lights[lightNumber].colorAndLightIntensity.xyz;
}

void computeRequiredSpotLightProperties(in vec4 currentVertexPosition, in vec3 currentNormal, in vec3 viewVector, in int lightNumber, out vec3 vertexToLightDirection, out vec3 reflectedLightDirection, out vec3 lightColor, out float lightIntensity)
{
	vec4 current_light_position = CurrentCamera.viewMatrix * Lights[lightNumber].position;
    vertexToLightDirection = normalize((current_light_position - currentVertexPosition).xyz);
    reflectedLightDirection = reflect(-vertexToLightDirection, currentNormal);
    lightIntensity = Lights[lightNumber].colorAndLightIntensity.w;
	lightColor = Lights[lightNumber].colorAndLightIntensity.xyz;
}

void computeRequiredDirectionalLightProperties(in vec4 currentVertexPosition, in vec3 currentNormal, in vec3 viewVector, in int lightNumber, out vec3 vertexToLightDirection, out vec3 reflectedLightDirection, out vec3 lightColor, out float lightIntensity)
{
	vec4 current_light_position = CurrentCamera.viewMatrix * Lights[lightNumber].position;
    vertexToLightDirection = normalize((current_light_position - currentVertexPosition).xyz);
    reflectedLightDirection = reflect(-vertexToLightDirection, currentNormal);
    lightIntensity = Lights[lightNumber].colorAndLightIntensity.w;
	lightColor = Lights[lightNumber].colorAndLightIntensity.xyz;
}

void computeRequiredLightProperties(in vec4 currentVertexPosition, in vec3 currentNormal, in vec3 viewVector, in int lightNumber,  out vec3 vertexToLightDirection, out vec3 reflectedLightDirection, out vec3 lightColor, out float lightIntensity)
{
	if(Lights[lightNumber].enabledLocalLightType[2] == 1.0)
	{
        computeRequiredPointLightProperties(currentVertexPosition, currentNormal, viewVector, lightNumber, vertexToLightDirection, reflectedLightDirection, lightColor, lightIntensity);
    }
	else if(Lights[lightNumber].enabledLocalLightType[2] == 2.0)
    {
        computeRequiredSpotLightProperties(currentVertexPosition, currentNormal, viewVector, lightNumber, vertexToLightDirection, reflectedLightDirection, lightColor, lightIntensity);    
    }
	else if(Lights[lightNumber].enabledLocalLightType[2] == 3.0)
    {
        computeRequiredDirectionalLightProperties(currentVertexPosition, currentNormal, viewVector, lightNumber, vertexToLightDirection, reflectedLightDirection, lightColor, lightIntensity);
    }
    else
    {
        vertexToLightDirection = vec3(0.0, 1.0, 0.0);
        reflectedLightDirection = vec3(0.0, 1.0, 0.0);
        lightIntensity = 0.0;
    }
}

void computeAmbientDiffuseSpecularLightingColor(in vec4 currentVertexPosition, in vec3 currentNormal, in int lightNumber, in vec3 currentMaterialDiffuseAlbedo, in vec3 currentMaterialSpecularAlbedo, in float currentMaterialMetallicness, in float currentMaterialRoughness, out vec3 computedLightingColor)
{
    vec3 viewVector = normalize(-currentVertexPosition.xyz / currentVertexPosition.w);

    vec3 vertexToLightDirection;
    vec3 reflectedLightDirection;
    vec3 lightColor;
    
    float lightIntensity;
    
    
    computeRequiredLightProperties(currentVertexPosition, currentNormal, viewVector, lightNumber, vertexToLightDirection, reflectedLightDirection, lightColor, lightIntensity);
    
    computeMaterialLighting(currentVertexPosition, currentNormal, viewVector, vertexToLightDirection, reflectedLightDirection, lightColor, lightIntensity, currentMaterialDiffuseAlbedo, currentMaterialSpecularAlbedo, currentMaterialMetallicness, currentMaterialRoughness, computedLightingColor);

}


void getMaterialProperties(out vec4 currentMaterialDiffuseAlbedo, out vec3 currentMaterialSpecularAlbedo, out vec3 currentMaterialEmissiveColor, out float currentMaterialMetallicness, out float currentMaterialRoughness, out float currentMaterialOpacity)
{
	
	currentMaterialDiffuseAlbedo = texture(diffuse_albedo_sampler, vec2(texture_coordinates.x, texture_coordinates.y));
	currentMaterialDiffuseAlbedo.w = 1.0;

	vec4 currentMaterialSpecularAlbedoRoughness = texture(specular_albedo_and_roughness_sampler, vec2(texture_coordinates.x, texture_coordinates.y));
	currentMaterialSpecularAlbedo = currentMaterialSpecularAlbedoRoughness.xyz;
	currentMaterialRoughness = currentMaterialSpecularAlbedoRoughness.w;


	vec4 currentMaterialEmissiveColorMetallicness = texture(emission_and_metallicness_sampler, vec2(texture_coordinates.x, texture_coordinates.y));
	currentMaterialEmissiveColor = currentMaterialEmissiveColorMetallicness.xyz;
	currentMaterialMetallicness = currentMaterialEmissiveColorMetallicness.w;

	currentMaterialOpacity = 1.0;
}



void main()
{

	vec4 currentVertexPosition =  vec4(texture(vertex_position_sampler, vec2(texture_coordinates.x, texture_coordinates.y)).xyz, 1.0);
    vec3 currentNormal = texture(vertex_normal_and_materialID_sampler, vec2(texture_coordinates.x, texture_coordinates.y)).xyz;

	vec4 materialDiffuseAlbedo;
	vec3 materialSpecularAlbedo;
	vec3 materialEmissive;
	float materialMetallicness;
	float materialRoughness;
	float materialOpacity;

	getMaterialProperties(materialDiffuseAlbedo, materialSpecularAlbedo, materialEmissive, materialMetallicness, materialRoughness, materialOpacity);

	vec3 currentLightingColor;
	vec3 totalLightingColor;



	for(int i = 0; i < MAX_LIGHTS; i++)
	{
		if(Lights[i].enabledLocalLightType[0] == 1.0)
		{
			computeAmbientDiffuseSpecularLightingColor(currentVertexPosition, currentNormal, i, materialDiffuseAlbedo.xyz, materialSpecularAlbedo, materialMetallicness, materialRoughness, currentLightingColor);            
            totalLightingColor += currentLightingColor;
		}
	}

	color = vec4(totalLightingColor, materialOpacity);
}